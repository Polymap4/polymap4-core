/* 
 * polymap.org
 * Copyright (C) 2014, Falko Bräutigam. All rights reserved.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 3.0 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 */
package org.polymap.core.runtime.i18n;

import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.Properties;
import java.util.ResourceBundle;
import java.util.Set;
import java.util.TreeSet;

import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;

import org.apache.commons.io.IOUtils;

import org.eclipse.jface.viewers.ITreeContentProvider;
import org.eclipse.jface.viewers.Viewer;

/**
 * Provides a model to read and manipulate {@link ResourceBundle} and key/value based
 * maps of localized strings in general. It can be used as
 * {@link ITreeContentProvider} for a {@link ResourceBundleTreeViewer}.
 * 
 * @author <a href="http://www.polymap.de">Falko Bräutigam</a>
 */
public class ResourceBundleModel
        implements ITreeContentProvider {

    private Map<String,String>      entries = new HashMap( 64 );
    
    private Map<String,String>      modified = new HashMap( 64 );
    
    private String                  keySeparator = MessagesImpl.SEPARATOR;
    
    private boolean                 dirty = false;

    
    public boolean isDirty() {
        return dirty;
    }


    public String getKeySeparator() {
        return keySeparator;
    }
    
    
    public void setKeySeparator( String keySeparator ) {
        this.keySeparator = keySeparator;
    }


    public String getEntryValue( String key ) {
        return modified.containsKey( key ) ? modified.get( key ) : entries.get( key );
    }

    
    public ResourceBundleModel setEntryValue( String key, String value ) {
        String old = getEntryValue( key );
        if (old == null || !old.equals( value )) {
            modified.put( key, value );
            dirty = true;
        }
        return this;
    }

    
    public void save( File file, boolean clearModified ) throws IOException {
        OutputStream out = null;
        InputStream in = null;
        try {
            Properties props = new Properties();
            if (file.exists()) {
                in = new BufferedInputStream( new FileInputStream( file ) );
                props.load( in );
            }
            props.putAll( modified );
            out = new BufferedOutputStream( new FileOutputStream( file ) );
            props.store( out, " Generated by Polymap3 I18N Editor (http://polymap.org/polymap3)" );
            
            dirty = false;
            if (clearModified) {
                modified.clear();
            }
        }
        finally {
            IOUtils.closeQuietly( out );
            IOUtils.closeQuietly( in );
        }
    }

    
    // ITreeContentProvider *******************************
    
    @Override
    public void inputChanged( Viewer viewer, Object oldInput, Object newInput ) {
        // properties file
        if (newInput instanceof File) {
            InputStream in = null;
            try {
                in = new BufferedInputStream( new FileInputStream( (File)newInput ) );
                Properties props = new Properties();
                props.load( in );
                modified.clear();
                entries.clear();
                entries.putAll( new HashMap( props ) );
            }
            catch (Exception e) {
                throw new RuntimeException( e );
            }
            finally {
                IOUtils.closeQuietly( in );
            }
        }
        // ResourceBundle
        else if (newInput instanceof ResourceBundle) {
            modified.clear();
            entries.clear();

            ResourceBundle rb = ((ResourceBundle)newInput);
            for (String key : Collections.list( rb.getKeys() )) {
                entries.put( key, ((ResourceBundle)newInput).getString( key ) );
            }
        }
        // clear after dispose
        else if (newInput == null) {
            entries = null;
        }
        else {
            throw new RuntimeException( "not yet supported input type: " + newInput.getClass().getName() );
        }
    }

    
    @Override
    public Object[] getElements( Object inputElement ) {
        return getChildren( null );
    }

    
    @Override
    public Object[] getChildren( Object parentElm ) {
        Set<String> result = new TreeSet();
        
        String prefix = parentElm != null && ((String)parentElm).startsWith( "@" ) 
                ? ((String)parentElm).substring( 1 ) : "";
                
        int startIndex = prefix.length() + 1;
        for (String key : entries.keySet()) {
            if (key.startsWith( prefix ) && key.length() > startIndex) {
                int endIndex = key.indexOf( keySeparator, startIndex );
                // leaf
                if (endIndex == -1) {
                    result.add( key );
                }
                // branch
                else {
                    String elm = "@" + key.substring( 0, endIndex );
                    result.add( elm );
                }
            }
        }
        return result.toArray();
        
//        Iterable<String> results = filter( entries.keySet(), isChild( (String)parentElm ) );
//        results = transform( results, cutSuffix( (String)parentElm ) );
//        return toArray( results, String.class );
    }

    
    @Override
    public boolean hasChildren( Object element ) {
        return getChildren( element ).length > 0;
        
//        return find( entries.keySet(), isChild( (String)element ), null ) != null;
    }


    @Override
    public Object getParent( Object element ) {
        // XXX Auto-generated method stub
        throw new RuntimeException( "not yet implemented." );
    }


    @Override
    public void dispose() {
    }
    
    
//    protected Predicate<String> isChild( final String prefix ) {
//        return new Predicate<String>() {
//            private Set<String> seen = new HashSet();
//            public boolean apply( String input ) {
//                return (prefix == null 
//                        || (input.startsWith( prefix ) && prefix.length() < input.length()))
//                        && seen.add( input );
//            }
//        };
//    }
//    
//    
//    protected Function<String,String> cutSuffix( final String prefix ) {
//        return new Function<String,String>() {
//            public String apply( String input ) {
//                //Splitter.on( keySeparator ).split( input )
//                String tail = prefix != null ? StringUtils.substring( input, prefix.length() ) : input;
//                String nextElm = StringUtils.substringBefore( tail, keySeparator );
//                return prefix + keySeparator + nextElm; 
//            }
//        };
//    }
    
}
